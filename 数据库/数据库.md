# 1. Redis（7.0版本）

- 概述

## 1.1 Windows下安装

- 官网

  - **Redis官方**网站提供的版本通常是**源代码版本**。这些源代码可以在各种操作系统上进行**编译**和**安装**。
  - 用户可以根据**自己的需求和操作系统**选择来构建适合他们环境的Redis版本
  - Windows用户，需要额外的步骤和工具来在Windows上构建和运行Redis
  - [Download | Redis --- 下载 |雷迪斯](https://redis.io/download/#redis-downloads)
  - 总结：大可不必

- Windows版本下载

  1. https://github.com/tporadowski/redis/releases **（推荐使用）**
  2. https://github.com/MicrosoftArchive/redis/releases

- **安装**

  1. 下载msi安装包，执行

  2. 越过防火墙，保证外部可以正常访问redis服务

     ![win安装redis](..\实例图片\win安装redis.png)

  3. 设置最大缓存容量

     ![win安装redis最大缓存](..\实例图片\win安装redis最大缓存.png)

  

- **配置**

  - [参考](https://blog.csdn.net/weixin_41381863/article/details/88231397)

  - 注意配置文件有两个：**redis.windows-service.conf**和**redis.windows.conf**，它们对应着Windows系统两种启动模式：

    1. **非服务方式（non-service mode）**：在非服务方式下，直接运行 `redis-server.exe` 命令来启动 Redis 服务器，**默认使用**的是**redis.windows.conf**里的配置。这种模式适用于**临时开发、测试、调试**等场景。主要区别如下：
       - Redis 进程将在命令行窗口中启动，可以在该窗口中看到 Redis 的日志输出。
       - 可以通过关闭命令行窗口来停止 Redis 服务器。
       - 该模式适合于**单次启动**，**不会在系统启动时自动运行**。
    2. **服务方式（service mode）**：在服务方式下，将 Redis 配置为 Windows 服务，**默认使用**的是**redis.windows-service.conf**里的配置。使其可以在系统启动时**自动运行**。这种模式适用于生产环境或需要持续运行的情况。主要区别如下：
       - Redis 作为 Windows 服务在**后台运行**，**不需要用户交互。**
       - Redis 服务的启动、停止和管理可以通过 Windows 服务管理工具进行，如 Services.msc。
       - Redis 服务会**在系统启动时自动启动**，即使没有用户登录也能正常运行。
       - 日志输出通常会记录在系统事件日志中。

  - 配置项

    ![redis配置1](..\实例图片\redis配置1.png)

    ![redis配置2](..\实例图片\redis配置2.png)

    ![redis配置3](..\实例图片\redis配置3.png)

    ![redis配置4](..\实例图片\redis配置4.png)

    

## 1.2 Linux下安装

# 2. mysql

# 3. MongoDB

- 概述

  1. 基于分布式文件存储的数据库
  2. 管理数据，增删改查
  3. 相比于纯文件管理数据，数据库管理数据有如下特点：
     - 速度更快
     - 扩展性更强
     - 安全性更强

- 核心概念：

  - 数据库（database） 数据库是一个数据仓库，数据库服务下可以创建很多数据库，数据库中可以存 放很多集合
  - 集合（collection） 集合类似于 JS 中的数组，在集合中可以存放很多文档 
  - 文档（document） 文档是数据库中的最小单位，类似于 JS 中的对象

  ![mongodb架构](C:\Users\admin\Desktop\coolShare\实例图片\mongodb架构.png)

## 3.1 下载安装

- [下载地址](https://www.mongodb.com/try/download/community-kubernetes-operator)

  - 压缩包自定义安装(.zip)

    1. 解压

    2. 数据库保存位置

       - 自定义数据库保存位置

         1. 自定义创建文件夹`data/db`

         2. 启动服务器的时候设置自定义位置，每次都要这样

            解压mongodb里的bin文件夹下：`mongod --dbpath ../data/db`

       - 数据库默认保存位置（方便推荐）

         1. windows系统下，数据库默认保存位置取决于启动mongodb命令的位置

         2. 比如启动命令位置：`E:\mongodb\mongodb-win32-x86_64-windows-6.0.7\bin`

            数据库默认保存位置:`E:\data\db`

         3. 需要自己常见data和db文件夹，否则运行`mongodb`会报错，提示找不到`E:\data\db`

         4. 解压mongodb里的bin文件夹下：`mongod`

    3. 还可以配置mongodb数据库服务，目的是数据库随电脑自启

       [参考](https://blog.csdn.net/weixin_43898497/article/details/115452745)

  - 安装包安装(.mis)

    - 一步步点击安装就行，会自动创建数据库保存位置和配置mongodb数据库服务
    - 适合服务器部署阶段

- 图形化管理工具

  - [Robo 3T 免费]( https://github.com/Studio3T/robomongo/releases)
  - [Navicat 收费](https://www.navicat.com.cn/) 

## 3.2 mongoose代码操作mongodb

[参考](https://blog.csdn.net/weixin_45828332/article/details/114120710)

- 概述

  1. Mongoose 是一个可以通过Node来操作MongoDB数据库的一个模块
  2. Mongoose 是一个对象文档模型（ODM）库，它是对Node原生的MongoDB模块进行了进一步的优化封装

- 基本流程

  1. 安装mongoose：`npm i mongoose`

  2. 导入mongoose：`const mongoose = require('mongoose')`

  3. 连接mongoose服务，包括mongodb下协议，ip，端口，数据库名：

     `mongoose.connect('mongodb://127.0.0.1:27017/bilibili')`

  4. 给服务不同结果设置回调，connection后的事件绑定继承[EventEmitter]([Events | Node.js v20.4.0 Documentation (nodejs.org)](https://nodejs.org/api/events.html#class-eventemitter))，函数里第一个参数是[事件关键词](https://mongoosejs.com/docs/connections.html)对应不同的结果。第二个参数是回调函数，里面开始操作数据库里的增删改查：

     - 成功：`mongoose.connection.on('open', () => {})`
     - 出错：`mongoose.connection.on('error', () => {})`
     - 关闭：`mongoose.connection.on('close', () => {})`

  5. 回调函数里写业务逻辑里的增删改查

     - 创建文档结构Schema对象，设置文档字段和数据类型

       ```js
       let BookSchema = new mongoose.Schema({
           title: String,
           author: String,
           price: Number
       });
       ```

     - 创建文档模型model对象，设置给Schema对象指定集合，并封装了增删改查的操作

       `let BookModel = mongoose.model('book', BookSchema)`

     - 增删改查 `userModel.method({}).then(function(data){})).catch(function(err){})`

       注意：Model.create() no longer accepts a callback，报错：

       ```js
       //报错
       BookModel.create({
           title: '西游记',
           author: '吴承恩',
           price: 19.9
       }, (err, data) =>{
           //错误
           console.log(err);
           //插入后的数据对象
           console.log(data);
       });
       
       //正确示范,then是成功插入数据库，catch是插入失败
       BookModel.create({
           title: '西游记',
           author: '吴承恩',
           price: 19.9
       }).then((data) =>{
               //插入后的数据对象
               console.log(data);
       }).catch((err) =>{
               //错误
               console.log(err);
       });
       ```

- 模块化

  完整流程：

  ```js
  //1. 安装 mongoose
  //2. 导入 mongoose
  const mongoose = require('mongoose');
  
  //设置 strictQuery 为 true
  mongoose.set('strictQuery', true);
  
  //3. 连接 mongodb 服务                        数据库的名称
  mongoose.connect('mongodb://127.0.0.1:27017/bilibili');
  
  //4. 设置回调
  // 设置连接成功的回调  once 一次   事件回调函数只执行一次
  mongoose.connection.once('open', () => {
    //5. 创建文档的结构对象
    //设置集合中文档的属性以及属性值的类型
    let BookSchema = new mongoose.Schema({
      name: String,
      author: String,
      price: Number,
      is_hot: Boolean
    });
  
    //6. 创建模型对象  对文档操作的封装对象    mongoose 会使用集合名称的复数, 创建集合
    let BookModel = mongoose.model('novel', BookSchema);
  
    //7. 新增
    BookModel.insertMany([{
      name: '西游记',
      author: '吴承恩',
      price: 19.9,
      is_hot: true
    }, {
      name: '红楼梦',
      author: '曹雪芹',
      price: 29.9,
      is_hot: true
    },]).then((err, data) => {
      //判断是否有错误
      if (err) {
        console.log(err);
        return;
      }
      //如果没有出错, 则输出插入后的文档对象
      console.log(data);
      //8. 关闭数据库连接 (项目运行过程中, 不会添加该代码)
      mongoose.disconnect();
    });
  
  });
  
  // 设置连接错误的回调
  mongoose.connection.on('error', () => {
    console.log('连接失败');
  });
  
  //设置连接关闭的回调
  mongoose.connection.on('close', () => {
    console.log('连接关闭');
  });
  
  
  ```

  

  - mongoose操作mongodb数据库的流程很清楚，但是代码耦合高，连接数据库，创建文档，文档指定集合，增删改查形成一个流程。

  - 一个普遍的需求：

    1. 连接数据库只写一次就行，复用
    2. 创建文档结构，指定集合可以根据逻辑修改，需要复用
    3. 增删改查也可以根据逻辑修改

  - 模块化的方法：

    1. 最重要也是唯一有用的武器是node自己的[模块方法](###2.3.1 模块化)，需要服用的代码封装暴露为一个函数：`module.exports=function(){}`
    2. 分析谁和谁解耦，或者说谁和谁分开
    3. 剪切需要复用或者逻辑修改的代码，放到一个新文件保存，并且module.exports暴露

  - 解耦连接数据库代码：

    1. `mongoose.connection.on('open', callbackFunction)`

    2. 核心问题：`mongoose.connection.on('open',)`和`callbackFunction`如何分开
    3. 思路：`mongoose.connection.on('open',)`当做函数暴露，`callbackFunction`当做函数的参数

    新文件db/db.js

    ```js
    module.exports=function(success,erro){
        if (typeof error !=='function'){
            error = ()=>{
                console.log('连接失败')
            }
        }
    
        // 导入mongoose
        const mongoose = require('mongoose')
    
        mongoose.connect('mongodb://127.0.0.1:27017/bilibili')
    
        mongoose.connection.once('open', ()=>{
            success()
        })
    
        mongoose.connection.once('error', ()=>{
            error()
        })
    
        mongoose.connection.on('close', () => {
            console.log('连接关闭')
        })
    
    }
    ```

    调用文件index.js

    ```js
    // 导入mongoose
    const mongoose = require('mongoose')
    
    // 导入连接数据库函数
    const db = require('./db/db')
    
    function updateDB(){
        let BookSchema = new mongoose.Schema({
            title: String,
            author: String,
            price: Number
        })
    
        let BookModel = mongoose.model('book', BookSchema)
    
        BookModel.create({
            title: '红楼梦',
            author: '曹雪芹',
            price: 19.9
        }).then(
            (err, data) =>{
                //错误
                console.log(err);
                //插入后的数据对象
                console.log(data);
        });
      }
    //调用函数
    db(updateDB)
    ```

  - 解耦创建文档结构、给文档指定集合和增删改查

    1. `let BookSchema = new mongoose.Schema();let BookModel = mongoose.model('book', BookSchema)`和`BookModel.create().then()`分开
    2. 需要明确哪两部分代码解耦，在结合`module.exports`语法思考如何封装。
    3. 再需要明确谁复用就封装谁

    新文件：model/BookModel.js

    ```js
    // 导入mongoose
    const mongoose = require('mongoose')
    
    let BookSchema = new mongoose.Schema({
        title: String,
        author: String,
        price: Number
    })
    
    let BookModel = mongoose.model('book', BookSchema)
    
    module.exports=BookModel
    ```

    调用文件index.js

    ```js
    // 导入mongoose
    const mongoose = require('mongoose')
    
    // 导入连接数据库函数
    const db = require('./db/db')
    const BookModel=require('./model/BookModel')
    
    function updateDB(){
        BookModel.create({
            title: '红楼梦',
            author: '曹雪芹',
            price: 19.9
        }).then(
            (err, data) =>{
                //错误
                console.log(err);
                //插入后的数据对象
                console.log(data);
        });
      }
    
    // 调用
    db(updateDB)
    
    ```

    

