# Git-分布式版本管理软件

# 1. Git分布式

- 背景和动机：开发项目中，代码、文档等文件修改，删除，创建。需要管理文件变化过程，设计一个软件：
  - 能记录文件从0到现在的所有过程
  - 回到文件过去某个时间点
  - 记录文件变化时的信息提示
  - 多人合作开发项目，能异步进行
  
- 版本管理软件的思路：
  1. 互联网最常见的服务端和客户端思路。代码都放在服务器里，客户端从服务器下载项目代码，修改、创建、删除文件后提交到服务器。
     - 优点：简单医用，方便监视项目进程，访问安全，本地存储小
     - 缺点：网络依赖，服务器单点故障，分支合并操作复杂
  2. 分布式思路：

- git没有服务器的概念，或者说每一个git代码库都是服务器。

- 分布式软件，相反面的是，集中式软件

- blob（文件快照）、tree、commit

  ![git中的commit、tree、blob](..\示例图片\git中的commit、tree、blob.png)



- Git目的是，管理软件开发项目中的源代码文件

- 直觉有朴素的想法：

  1. 开发软件，有个项目，开发过程中，少不了创建、删除、修改文件和文件夹。
  2. 一般情况下，项目保存在我自己的电脑硬盘上，这个有了一下问题（意味着需求）：
     - 一旦保存以后，是没办法回到过去的
     - 也不知道某一次修改删除具体都有哪些变动
     - 别人没办法修改，没办法一起合作开发

- `Git`应运而生，其核心是**git管理对象（本地代码库）**：

  - 会一直跟踪整个软件开发的项目
  - 记录每一次项目的变化，保证能随时回到过去和现在
  - 显示的项目（**工作区**）只是**仓库**其中的某个版本
  - 硬盘里的文件或目录，通过`git init`初始化以后会变成一个git管理对象。原来的项目里会多了一个`.git`的文件夹。.git就是仓库。

- git的思路

  1. `git init`让普通的目录初始化为一个git管理对象
  2. 里面的`.git`文件夹是管理对象的核心，是仓库，里面会记录实现功能的所有信息。
     - 会记录每一次版本的文件和更改信息。这使得git可以回到过去和现在。知悉每一次更改的信息。
     - 会记录多个分支。这使得git可以实现多人合作。
  3. 但是，`.git`文件夹当然不是复制每次版本的文件，而是通过一种无损压缩的办法，能记录每一次版本文件，并且非常有效的减少占用内存。

- git管理对象包括三部分：工作区、暂存区、仓库

  - 仓库分为本地仓库和远程仓库。远程仓库保存在代码托管平台，方便分享和合作开发。

  - 仓库包括：`工作区`，`暂存区`，`仓库`

    ![仓库](..\示例图片\仓库.png)

  1. **工作区：**电脑能看到的目录。有四种状态。

     ![工作区四种状态](..\示例图片\工作区四种状态.png)

     - **未被追踪**：比如新建一个文件，仓库压根不知道这个文件，或者说这文件还没有和仓库产生联系。需要`git add file`将文件加入仓库，文件进入**暂存区**，仓库可以追踪文件的变化了。
     - **已修改**
     - **已暂存**：`git add file`后的状态，文件会进入暂存区，仓库开始跟踪文件。这时候文件不稳定。如果，，需要`git commit`来告诉仓库有哪些变动信息。之后文件才入库。
     - **已提交**：这文件正式获得版本管理功能。可以再次修改进入暂存区，然后再次入库。同时还可以将过去的版本覆盖当前工作区的文件，也就是回到过去。
     - **查看文件状态**：`git status`

  2. **暂存区：**英文叫 stage 或 index。一般存放在 **.git** 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。
     - `git add`文件进入暂存区
     - 已经入库的文件修改，进入暂存区

  3. **版本库：**工作区有一个隐藏目录 **.git**，这个不算工作区，而是 Git 的版本库。

  4. 

- 功能思路:

  - 仓库管理
  - 文件管理
  - 分支管理
  - 标签管理
  - 远程操作
  
- 删除操作：

  `git rm file`=`非git删除`+`git add file` 就是工作区就删除文件，并且提交到暂存区

  `git rm --cached file` 其实就是git不再追踪file，并且提交到暂存区，但是在工作区不删除file

  `git rm file`还原操作：

  1.从staged状态还原到modify状态：`git restore --staged file` 

  2.从modify状态还原到unmodify状态：`git restore  shop.txt`

  `git rm --cached file`还原操作：

  1.从staged状态还原到modify状态：`git restore --staged file` 

  不需要`git restore  shop.txt`因为根本就没有更改工作区。

- 重命名和移动操作

  `git rm file newfile` = 非git重命名+`git add file newfile`

  其实就是重命名，并且提交暂存区。
  
- 撤销操作（谨慎危险，因为git里提交过的东西都可以恢复，暂存区和工作区里的修改内容丢失就是真丢失了）

  `git reset HEAD file`= `git restore --staged file `撤销暂存区到工作区

  `git checkout -- file `=`git restore file` 撤销工作区的修改到最近一次提交

- 添加和删除远程仓库

  `git remote add <shortname> <url>`

  `git remote remove <shortname>`

  引起的变化就是`.git/config添加remote信息`

- 设置代理

  需要快柠檬，端口10794是软件查的

  `git config --global https.proxy http://127.0.0.1:10794`

  `git config --global http.proxy http://127.0.0.1:10794`

  取消代理：

  `git config --global --unset http.proxy `

  `git config --global --unset https.proxy`

  - 但是有个问题：

    启动了科学上网工具，git就用科学上网的端口代理。一旦关掉了科学上网工具，git还是代理，会造成git无法上网。

# 2. git软件

- 下载，安装：[Git](https://git-scm.com/)
- Git配置
  - Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。
  - `git config --global user.email "marslongnose@gmail.com"`
  - `git config --global user.name "marslongnose"`
- 初始化Git
  - 一个项目，想要被Git进行版本控制，首先就要成为一个Git仓库。这就是git初始化
  - `git init`：初始化以后，才有仓库一说，否则项目只是一个文件夹
  - 初始化并不需要git配置里的名字和邮箱

# 3. 分支

- 概述

  ![git分支](..\示例图片\git分支.png)

  - 每次提交都会生成一个SHA-1（Secure Hash Algorithm 1）散列值。散列值可以当成一个索引，可以找到提交对应的文件（blob，tree，commit）。
  - 第一次之后的提交对象会包含一个指针，指向上次提交对象（父对象）。
  - Git 分支，本质上仅仅是一个可变指针，指向某一次提交对象。   
  - Git 有一个名为 HEAD 的特殊指针，指向当前所在的本地分支。

- 创建分支

  - 创建分支，其实是创建了一个指针，可变指针。
  - 有了新提交，分支代表的指针就会改变位置。
  - 切换指针，其实就是HEAD指针指向改变了

- 分支合并的两种情况

  ![git分支合并](..\示例图片\git分支合并.png)

  1. 合并分支和被合并分支是直接后继关系。比如master和hotfix

     - 合并的分支 hotfix 所指向的提交 C4 是当前所在分支的提交 C2 的直接后继， 这种情况下， Git 会直接将指针向前移动

     - 简单说，当试图合并两个分支 时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进 （指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。

       ![git分支合并情况1](..\示例图片\git分支合并情况1.png)

  2. 合并分支和被合并分支的提交非直接后继关系。如：master和iss53

     - Git 会做一些额外的工作，Git 会使用两个分支的末端所指的快照（C4 和 C5 ）以及这两个分支的公共祖先（C2），做一个简单的三方合并。

     ![git分支合并情况2的三方合并](..\示例图片\git分支合并情况2的三方合并.png)

     - 合并之后，会产生一个新的提交，当然也会有新的快照文件和tree对象

     ![git分支合并情况2的结果](..\示例图片\git分支合并情况2的结果.png)

     

     

# 4. 合并冲突

- 不同的分支，对同一个文件的同一个部分进行了不同的修改
- https://zhuanlan.zhihu.com/p/192972614