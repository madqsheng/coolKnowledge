# 1.数据存储

- 概述：
  1. 计算机内的信息都是以二进制数表示，存储在内存中
  2. 计算机数据量的单位，从小到大包括：**位(比特)，字节，字，双字，四字**
  3. 计算机数据存储方式，决定了数据的最小计量单位是比特，1比特可以存一个1或者0。现实生活中的计量单位往往是个，只，米等。计量单位是物质存在原理决定。

## 1.1 位bit（比特）

- 更常见的称呼是比特，英文bit，简称b
- 计算机中度量数据的最小最基本的单位。
- 1比特其实就是一个物理空间，里面存储数据。由于数据是以二进制存在，1比特空间存的就是1或者0。

## 1.2 字节Byte

- 英文Byte，简称B，1B=8b 
- 虽然比特是数据的最小单位，但是字节才是最小可寻址单元，也就是数据存储位置的最小基本单位。一个字节有8位，也就是8bit，字节里的8位是共享一个地址。
- 每个字节的8比特数据往往被视为一个整体，按照连续的地址存储，允许计算机可以按照地址来寻址和访问字节数据。
- 问题1：既然字节内的比特数据共享一个地址，那么位操作是怎么找到对应的比特数据。

## 1.3 字、双字、四字

- 英文word，简写w
- 双字DW，四字QW
- 字是一个很重要的概念，是计算机内部进行数据传递、数据读写的最小单位。
- 1word等于多少Byte不固定。取决于处理器内部的通用寄存器的位数和数据总线的宽度。
- 计算机IBM PC/XT规定：
  - 1w=2B=16b
  - 1DW=4B
  - 1QW=8B

## 1.4 数量级 K/M/G/T

- K/M/G/T并没有是实质意义，只是一个数量级，类似于十/百/千/万，需要和数据单位一起用，比如KB,MB,GB,TB
- 在计算机里，1k=1024，原因在于存储数据的寄存器是二进制的，同时还要通过地址寄存器寻找数据寄存器里的数据，也就是寄存器既存数据，还计量有多少数据。1k=2^10^
- 同理：
  - 1k=2^10^=1024
  - 1m=2^20^=1024k
  - 1g=2^30^=1024m
  - 1t=2^40^=1024g

# 2.数据编码

- 数据有的分正负的，有的不分，也就是有符号数和无符号数。如何解决存储，一个朴素的想法是，先声明有无符号，无符号无需特殊设计，有符号的话，那么在存储空间（比如字节）内腾出一位区别正负，1代表正，0代表负；或则1代表负，0代表正
- 似乎数据表示设计就这样简单：最高位腾出来表示正负，1代表负，0代表正，其余位表示数值，这就是**原码**的思路：
  - +105  => 0 1101001      -105 => 1 1101001 
  - bug1:  +0 => 0 000000   +0 => 1 0000000
  - bug2: 1-2=1+(-2)   =>   0 0000001+1 0000010=1 0000011  =>  -3
  - 总结：原码思路，看似没问题，实际上0的表示不唯一，加减法（减法转换为加法）逻辑错误，虽然乘法和除法是对的。
- 改进一下思路：观察原码中正数和负数加法，符号位和数值位各自在相加，这是逻辑错误的原因。正数和负数相加，数值位应该相抵消，而不是相叠加，最终的符号位应该取决于哪边的数值位更大。所以要解决这个问题，正数或则负数的其中之一的数值位必须取反。这就是**反码**，具体编码就是，正数还是原码思路，负数的数值位取反，符号位不变：
  - 1-2=1+(-2)  =>  0 0000001+1 1111101=1 1111110  => - 1 (nice)
  - bug1: -1+(-2)  => 1 1111110 +1 1111101= 11 1111011 (溢出)
  - bug2: 1+(-1)  =>  0 0000001+1 1111110=1 1111111 => -0
  - bug3: +0 => 0 0000000    -0 => 1 1111111
  - 总结：反码思路，解决了一点正负数相加的问题，没有完全解决。0的表示还是不唯一，正负数太容易溢出了。
- 在改进一下思路：问题最关键也是最后的部分是0的编码，如何唯一编码0？反码里正负数溢出实际问题不大，-1+(-2)按照反码运算，最后得到11 1111011，去掉溢出的最高位就是1 1111011解码位-3，运算实际是正确的。那么来思考，如何唯一编码0？按照反码编码：+0 =0 0000000 ，-0 =1 1111111，怎样让他们统一呢？如果他们都+1会怎么样，前者变为0 0000001，后者变为：10 0000000溢出了，等一下，10 0000000去掉溢出位就是0 0000000，这不就是原码进而反码里的+0吗？为啥我非要两个一起+1啊？那如果编码思路就只规定负数的数值位取反再+1，正数不变，那么+0=0 0000000，-0 = 0 0000000，这就实现了唯一编码0，这就是**补码**思路。虽说，0唯一编码了，但是真的不太优雅，并且正数不变，负数加一，那么请问，最后加减法编码符合数学逻辑吗？拭目以待：
  -  1+(-2)  =>  0 0000001+1 1111110=1 1111111  => - 1 (nice)
  -  -1+2    =>  1 1111111+0 0000010=10 0000001  =>  1(溢出但正确)
  - -1+(-2)  =>  1 1111111+1 1111110=11 1111101 => -3(溢出但正确) 
  -  -1+1    =>  1 1111111+0 0000001=10 0000000  =>  0(溢出但正确)
  - 总结：唯一编码0，并且编码后的加减法再解码回去，可能会溢出，去掉溢出位以后，结果任然符合数学逻辑。
  - 补码编码：正数，符号位是0，数值位二进制照常表示；负数，符号位是1，数值位先二进制表示，然后数值位取反，然后数值位再+1，如果溢出则去掉溢出位。

## 2.1 原码

- 编码：
  1. 有符号数专属概念，设计符号位和数值位
  2. 最高位是符号位，后面是数值位
  3. 符号位为0表示正数，符号位为1表示负数
  4. 数值位二进制表示
- 解码：
  1. 符号位区分胜负
  2. 数值位二进制转换为十进制

## 2.2 反码

- 编码：
  1. 改进原码，符号位不变
  2. 正数的数值位不变，但是负数的数值位取反
- 解码：
  1. 先看符号位判断正负
  2. 如果是正数，数值位直接二进制转十进制
  3. 如果负数，数值位先取反，再二进制转十进制

## 2.3 补码

- 编码：
  1. 改进反码，符号位仍然不变
  2. 正数的数值位不变
  3. 负数的数值位先取反然后再+1，如果溢出则去掉溢出位
- 解码：
  1. 先看符号位判断正负
  2. 如果是正数，数值位直接二进制转十进制
  3. 如果负数，数值先-1，然后位取反，最后二进制转十进制

## 2.4 总结

1. 大前提，如果先声明是无符号数，直接二进制表示，不需要原码反码补码这么复杂的编码。
2. 如果声明是有符号数，在计算机中的编码方式是**补码**

# 3.数据运算

## 3.1加减乘除

## 3.2 为什么  

# 4.逻辑电路

- **逻辑很抽象，是一种推理规则，因果关系**
- **逻辑电路是一种数字电路，基本器件是晶体管，二极管等。主要部分是半导体材料**

## 4.1 半导体

- 概述

  1. 半导体是一种介于导体（如金属）和绝缘体（如非金属）之间的材料，一种材料类别，是所有电子器件的基础。
  2. 基于半导体材料制造的电子元件有：晶体管，二极管，太阳能电池

- 问题1：为什么现代电子器件选择半导体材料而不选择导电性更好的**金属材料**？

   根本原因是半导体材料在特定条件下导电性会改变，可以实现单向导电性，通过导电性改变可以实现很多逻辑运算。

- 问题2：什么是**超导**材料？**室温超导**有什么意义？

  - 超导材料是一种在低温条件下表现出**零电阻**和**完全排斥磁场**的特性的材料。
  - 室温超导是指在接近或达到室温（通常指摄氏20度或更高温度）时，材料仍然可以表现出超导特性。传统的超导材料需要极低的温度（接近绝对零度，约-273摄氏度）才能实现超导状态。室温超导最让人惦记的是零电阻和完全排斥磁场。意义有：**能源传输：** 超导材料可以用于输电线路，因为零电阻状态意味着能量在输电过程中几乎没有能量损耗。这将显著提高电能传输的效率，减少能源浪费。**能源储存：** 超导材料可以用于制造高效的超导电池，用于存储电能，实现更大容量和更长寿命的电池技术。**电子器件：** 室温超导可以使电子器件的性能和速度提高，同时降低功耗。例如，超导材料可以用于制造高速、低功耗的超导逻辑门，提升计算机的性能。**医疗：** 超导材料在医疗成像设备中有应用潜力，如磁共振成像（MRI），它可以提高成像分辨率和减少扫描时间。**交通：** 超导磁悬浮技术可以实现高速、低能耗的交通工具，如磁悬浮列车。

- 问题3：超导体的**完全排斥磁场**性质如何理解？

  - 
  - **完全排斥磁场**特征：当超导材料进入超导状态时，超导材料内部的电子呈现一种特殊的组织方式，被称为“**库珀对**”（Cooper Pairs）。当**外部磁场**进入超导材料附近时，磁场会引起库珀对的运动，但由于库珀对的运动受到一种称为“**伦道夫散射**”（London Dispersion）的相互作用的制约，电子无法与磁场发生耦合。
  - 结果，超导材料中的电流不会受到外部磁场的阻碍，而是继续在材料内部流动，产生一个与外部磁场相反方向的磁场。这种内部电流产生的磁场与外部磁场相互作用，产生一个反向的磁场，导致外部磁场在超导材料内部受到排斥，形成了所谓的**迈斯纳效应**。
  - 也就是说，进入超导状态后，并且附近出现外部磁场，超导材料会产生一个与外部磁场相反的磁场，对超导材料来说是排斥外部磁场，对外部磁场来说是推开超导材料远离外部磁场。
  - 具体就是：将一个薄的超导片被置于一个强磁铁上方，某种条件下，超导片进入超导状态，同时具备超导状态和外部磁场，那么就出现，外部磁场和超导材料互相排斥。这就是**磁悬浮现象**。

## 4.2 逻辑运算

- 基本逻辑运算包括三种：

  1. 与
  2. 或
  3. 非

- 问题1：已经有了加减乘除的**算术运算**，为什么计算机选择逻辑运损？

  **算术运算可以用逻辑运算推导**，并且**条件运算**也可以由逻辑运算实现，算术运算对此无能为力。

## 4.3 逻辑门电路—与或非

### 4.3.1 MOSFET晶体管

- 参考：[二极管与逻辑电路](https://zhuanlan.zhihu.com/p/148901103)

- 全称：金属氧化物半导体**场效应晶体管** Metal-Oxide-Semiconductor Field-Effect Transistor

- 组成：金属(Metal)、二氧化硅(氧化层，Oxide)、硅晶片(半导体，Semiconductor)

![mosfet](..\实例图片\mosfet.jpg)

- 分析特性（N型MOSFET）：

  - 参考[学习笔记：二极管与逻辑电路](https://zhuanlan.zhihu.com/p/148901103)

  - 当 V~G~=0 时，不会有电子的移动

  - 当V~G~逐渐增大并超过**阈值电压(Threshold Voltage)** V~tℎ~ 时，此时由于提供了足够大的自上而下的电场E，电子会往Gate方向聚集，从而形成**channel**；

  - 当V~G~> V~tℎ~ 时，由于**S接地**，S、D之间形成电压差，因此电子从S流向D，电流从D流向S，此时D处的电压是
    $$
    V_D = V_G - V_{th}
    $$

- 分类：

  1. **NMOS**：半导体类型是npn，Gate接**高电压(High Voltage or VDD)**时形成channel
  2. **PMOS**：半导体类型是pnp，Gate接**低电压(Low Voltage or GND)**时形成channel![nmos和pmos](..\实例图片\nmos和pmos.jpg)

- **CMOS（Complementary Metal Oxide Semiconductor）**：包含NMOS和PMOS的集成电路

### 4.3.2 CMOS构建与或非逻辑门

- **非门**

  ![非门](..\实例图片\非门.jpg)

- 与门

  ![与门](..\实例图片\与门.jpg)

- 或门

  ![或门](..\实例图片\或门.jpg)

### 4.3.3 逻辑门电路图形符号

![逻辑门符号大全](..\实例图片\逻辑门符号大全.png)

![逻辑门符号大全2](..\实例图片\逻辑门符号大全2.png)

![逻辑门符号大全3](..\实例图片\逻辑门符号大全3.png)

### 4.3.4 逻辑门电路实现算数运算

- 设计流程：

  **真值表**—**逻辑函数表达式**—**逻辑电路图**

- 全加器

  1. 真值表

     ![ ](..\实例图片\全加器真值表.png)

     - Ci-1是来自低位的进位，S~i~是和，C~i~是进位

  2. 逻辑函数表达式

     ![全加器的逻辑表达式](..\实例图片\全加器的逻辑表达式.png)

  3. 简化并设计电路

     ![全加器逻辑表达式简化](..\实例图片\全加器逻辑表达式简化.png)

     ![全加器电路图](..\实例图片\全加器电路图.png)

### 4.3.5 逻辑门电路实现条件运算

## 4.4 时序逻辑电路—存储数据

- 背景：
  - 逻辑门电路和组合逻辑门电路中，**输入变化，输出也会变化，数据并没有存储下来。**
- 问题1：如何存储数据？如何提现对数据的记忆功能？
  - 存储数据和记忆功能应该有两种模式：
    1. 写模式：输出等于输入
    2. 记忆模式：数据已经保存，**输出不跟随输入，保持上一次状态**
  - 两种模式应该可以切换。满足这个才能称之为**存储数据**

### 4.4.1 RS触发器

- **实现存储功能**

  - 最难的部分是记忆模式，**输出等于上一次状态**
  - 巧妙的解决办法是，**把输出也拿来当输入**

- RS触发器的思路：

  1. 输入是$R$和$S$，输出是$Q$和$\overline{Q}$，当然为了记忆功能，$Q$和$\overline{Q}$也会当输入
  2. 写模式下：
     - 输入：$R=0$ ，$S=1$         输出：$Q=1$，$\overline{Q}=0$
     - 输入：$R=1$ ，$S=0$         输出：$Q=0$，$\overline{Q}=1$
  3. 记忆模式：
     - 输入：$R=0$ ，$S=0$         输出：$Q=Q$，$\overline{Q}=\overline{Q}$

  - 注意：输入还有一种可能：$R=1$ ，$S=1$，约定这是被禁止的操作，没有逻辑意义。

- RS触发器电路图：

  ![RS触发器电路图](..\实例图片\RS触发器电路图.png)

- RS触发器真值表：

  ![RS触发器真值表](..\实例图片\RS触发器真值表.png)
