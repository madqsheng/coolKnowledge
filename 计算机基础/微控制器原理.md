# 1.数据存储

- 概述：
  1. 计算机内的信息都是以二进制数表示，存储在内存中
  2. 计算机数据量的单位，从小到大包括：**位(比特)，字节，字，双字，四字**
  3. 计算机数据存储方式，决定了数据的最小计量单位是比特，1比特可以存一个1或者0。现实生活中的计量单位往往是个，只，米等。计量单位是物质存在原理决定。

## 1.1 位bit（比特）

- 更常见的称呼是比特，英文bit，简称b
- 计算机中度量数据的最小最基本的单位。
- 1比特其实就是一个物理空间，里面存储数据。由于数据是以二进制存在，1比特空间存的就是1或者0。

## 1.2 字节Byte

- 英文Byte，简称B，1B=8b 
- 虽然比特是数据的最小单位，但是字节才是最小可寻址单元，也就是数据存储位置的最小基本单位。一个字节有8位，也就是8bit，字节里的8位是共享一个地址。
- 每个字节的8比特数据往往被视为一个整体，按照连续的地址存储，允许计算机可以按照地址来寻址和访问字节数据。
- 问题1：既然字节内的比特数据共享一个地址，那么位操作是怎么找到对应的比特数据。

## 1.3 字、双字、四字

- 英文word，简写w
- 双字DW，四字QW
- 字是一个很重要的概念，是计算机内部进行数据传递、数据读写的最小单位。
- 1word等于多少Byte不固定。取决于处理器内部的通用寄存器的位数和数据总线的宽度。
- 计算机**IBM PC/XT**规定：
  - 1w=2B=16b
  - 1DW=4B
  - 1QW=8B

## 1.4 数量级 K/M/G/T

- K/M/G/T并没有是实质意义，只是一个数量级，类似于十/百/千/万，需要和数据单位一起用，比如KB,MB,GB,TB
- 在计算机里，1k=1024，原因在于存储数据的寄存器是二进制的，同时还要通过地址寄存器寻找数据寄存器里的数据，也就是寄存器既存数据，还计量有多少数据。1k=2^10^
- 同理：
  - 1k=2^10^=1024
  - 1m=2^20^=1024k
  - 1g=2^30^=1024m
  - 1t=2^40^=1024g

# 2.数据编码

- 数据有的分正负的，有的不分，也就是有符号数和无符号数。如何解决存储，一个朴素的想法是，先声明有无符号，无符号无需特殊设计，有符号的话，那么在存储空间（比如字节）内腾出一位区别正负，1代表正，0代表负；或则1代表负，0代表正
- 似乎数据表示设计就这样简单：最高位腾出来表示正负，1代表负，0代表正，其余位表示数值，这就是**原码**的思路：
  - +105  => 0 1101001      -105 => 1 1101001 
  - bug1:  +0 => 0 000000   +0 => 1 0000000
  - bug2: 1-2=1+(-2)   =>   0 0000001+1 0000010=1 0000011  =>  -3
  - 总结：原码思路，看似没问题，实际上0的表示不唯一，加减法（减法转换为加法）逻辑错误，虽然乘法和除法是对的。
- 改进一下思路：观察原码中正数和负数加法，符号位和数值位各自在相加，这是逻辑错误的原因。正数和负数相加，数值位应该相抵消，而不是相叠加，最终的符号位应该取决于哪边的数值位更大。所以要解决这个问题，正数或则负数的其中之一的数值位必须取反。这就是**反码**，具体编码就是，正数还是原码思路，负数的数值位取反，符号位不变：
  - 1-2=1+(-2)  =>  0 0000001+1 1111101=1 1111110  => - 1 (nice)
  - bug1: -1+(-2)  => 1 1111110 +1 1111101= 11 1111011 (溢出)
  - bug2: 1+(-1)  =>  0 0000001+1 1111110=1 1111111 => -0
  - bug3: +0 => 0 0000000    -0 => 1 1111111
  - 总结：反码思路，解决了一点正负数相加的问题，没有完全解决。0的表示还是不唯一，正负数太容易溢出了。
- 在改进一下思路：问题最关键也是最后的部分是0的编码，如何唯一编码0？反码里正负数溢出实际问题不大，-1+(-2)按照反码运算，最后得到11 1111011，去掉溢出的最高位就是1 1111011解码位-3，运算实际是正确的。那么来思考，如何唯一编码0？按照反码编码：+0 =0 0000000 ，-0 =1 1111111，怎样让他们统一呢？如果他们都+1会怎么样，前者变为0 0000001，后者变为：10 0000000溢出了，等一下，10 0000000去掉溢出位就是0 0000000，这不就是原码进而反码里的+0吗？为啥我非要两个一起+1啊？那如果编码思路就只规定负数的数值位取反再+1，正数不变，那么+0=0 0000000，-0 = 0 0000000，这就实现了唯一编码0，这就是**补码**思路。虽说，0唯一编码了，但是真的不太优雅，并且正数不变，负数加一，那么请问，最后加减法编码符合数学逻辑吗？拭目以待：
  -  1+(-2)  =>  0 0000001+1 1111110=1 1111111  => - 1 (nice)
  -  -1+2    =>  1 1111111+0 0000010=10 0000001  =>  1(溢出但正确)
  - -1+(-2)  =>  1 1111111+1 1111110=11 1111101 => -3(溢出但正确) 
  -  -1+1    =>  1 1111111+0 0000001=10 0000000  =>  0(溢出但正确)
  - 总结：唯一编码0，并且编码后的加减法再解码回去，可能会溢出，去掉溢出位以后，结果任然符合数学逻辑。
  - 补码编码：正数，符号位是0，数值位二进制照常表示；负数，符号位是1，数值位先二进制表示，然后数值位取反，然后数值位再+1，如果溢出则去掉溢出位。

## 2.1 原码

- 编码：
  1. 有符号数专属概念，设计符号位和数值位
  2. 最高位是符号位，后面是数值位
  3. 符号位为0表示正数，符号位为1表示负数
  4. 数值位二进制表示
- 解码：
  1. 符号位区分胜负
  2. 数值位二进制转换为十进制

## 2.2 反码

- 编码：
  1. 改进原码，符号位不变
  2. 正数的数值位不变，但是负数的数值位取反
- 解码：
  1. 先看符号位判断正负
  2. 如果是正数，数值位直接二进制转十进制
  3. 如果负数，数值位先取反，再二进制转十进制

## 2.3 补码

- 编码：
  1. 改进反码，符号位仍然不变
  2. 正数的数值位不变
  3. 负数的数值位先取反然后再+1，如果溢出则去掉溢出位
- 解码：
  1. 先看符号位判断正负
  2. 如果是正数，数值位直接二进制转十进制
  3. 如果负数，数值先-1，然后位取反，最后二进制转十进制

## 2.4 总结

1. 大前提，如果先声明是无符号数，直接二进制表示，不需要原码反码补码这么复杂的编码。
2. 如果声明是有符号数，在计算机中的编码方式是**补码**

# 3.逻辑电路

- **逻辑很抽象，是一种推理规则，因果关系**
- **逻辑电路是一种数字电路，基本器件是晶体管，二极管等。主要部分是半导体材料**

## 3.1 半导体

- 概述

  1. 半导体是一种介于导体（如金属）和绝缘体（如非金属）之间的材料，一种材料类别，是所有电子器件的基础。
  2. 基于半导体材料制造的电子元件有：晶体管，二极管，太阳能电池

- 问题1：为什么现代电子器件选择半导体材料而不选择导电性更好的**金属材料**？

   根本原因是半导体材料在特定条件下导电性会改变，可以实现单向导电性，通过导电性改变可以实现很多逻辑运算。

- 问题2：什么是**超导**材料？**室温超导**有什么意义？

  - 超导材料是一种在低温条件下表现出**零电阻**和**完全排斥磁场**的特性的材料。
  - 室温超导是指在接近或达到室温（通常指摄氏20度或更高温度）时，材料仍然可以表现出超导特性。传统的超导材料需要极低的温度（接近绝对零度，约-273摄氏度）才能实现超导状态。室温超导最让人惦记的是零电阻和完全排斥磁场。意义有：**能源传输：** 超导材料可以用于输电线路，因为零电阻状态意味着能量在输电过程中几乎没有能量损耗。这将显著提高电能传输的效率，减少能源浪费。**能源储存：** 超导材料可以用于制造高效的超导电池，用于存储电能，实现更大容量和更长寿命的电池技术。**电子器件：** 室温超导可以使电子器件的性能和速度提高，同时降低功耗。例如，超导材料可以用于制造高速、低功耗的超导逻辑门，提升计算机的性能。**医疗：** 超导材料在医疗成像设备中有应用潜力，如磁共振成像（MRI），它可以提高成像分辨率和减少扫描时间。**交通：** 超导磁悬浮技术可以实现高速、低能耗的交通工具，如磁悬浮列车。

- 问题3：超导体的**完全排斥磁场**性质如何理解？

  - **完全排斥磁场**特征：当超导材料进入超导状态时，超导材料内部的电子呈现一种特殊的组织方式，被称为“**库珀对**”（Cooper Pairs）。当**外部磁场**进入超导材料附近时，磁场会引起库珀对的运动，但由于库珀对的运动受到一种称为“**伦道夫散射**”（London Dispersion）的相互作用的制约，电子无法与磁场发生耦合。
  - 结果，超导材料中的电流不会受到外部磁场的阻碍，而是继续在材料内部流动，产生一个与外部磁场相反方向的磁场。这种内部电流产生的磁场与外部磁场相互作用，产生一个反向的磁场，导致外部磁场在超导材料内部受到排斥，形成了所谓的**迈斯纳效应**。
  - 也就是说，进入超导状态后，并且附近出现外部磁场，超导材料会产生一个与外部磁场相反的磁场，对超导材料来说是排斥外部磁场，对外部磁场来说是推开超导材料远离外部磁场。
  - 具体就是：将一个薄的超导片被置于一个强磁铁上方，某种条件下，超导片进入超导状态，同时具备超导状态和外部磁场，那么就出现，外部磁场和超导材料互相排斥。这就是**磁悬浮现象**。

## 3.2 逻辑运算

- 基本逻辑运算包括三种：

  1. 与
  2. 或
  3. 非

- 问题1：已经有了加减乘除的**算术运算**，为什么计算机选择逻辑运损？

  **算术运算可以用逻辑运算推导**，并且**条件运算**也可以由逻辑运算实现，算术运算对此无能为力。

## 3.3 逻辑门电路—与或非

### 3.3.1 MOSFET晶体管

- 参考：[二极管与逻辑电路](https://zhuanlan.zhihu.com/p/148901103)

- 全称：金属氧化物半导体**场效应晶体管** Metal-Oxide-Semiconductor Field-Effect Transistor

- 组成：金属(Metal)、二氧化硅(氧化层，Oxide)、硅晶片(半导体，Semiconductor)

![mosfet](..\示例图片\mosfet.jpg)

- 分析特性（N型MOSFET）：

  - 参考[学习笔记：二极管与逻辑电路](https://zhuanlan.zhihu.com/p/148901103)

  - 当 V~G~=0 时，不会有电子的移动

  - 当V~G~逐渐增大并超过**阈值电压(Threshold Voltage)** V~tℎ~ 时，此时由于提供了足够大的自上而下的电场E，电子会往Gate方向聚集，从而形成**channel**；

  - 当V~G~> V~tℎ~ 时，由于**S接地**，S、D之间形成电压差，因此电子从S流向D，电流从D流向S，此时D处的电压是
    $$
    V_D = V_G - V_{th}
    $$

- 分类：

  1. **NMOS**：半导体类型是npn，Gate接**高电压(High Voltage or VDD)**时形成channel
  2. **PMOS**：半导体类型是pnp，Gate接**低电压(Low Voltage or GND)**时形成channel![nmos和pmos](..\示例图片\nmos和pmos.jpg)

- **CMOS（Complementary Metal Oxide Semiconductor）**：包含NMOS和PMOS的集成电路

### 3.3.2 CMOS构建与或非逻辑门

- **非门**

  ![非门](..\示例图片\非门.jpg)

- 与门

  ![与门](..\示例图片\与门.jpg)

- 或门

  ![或门](..\示例图片\或门.jpg)

### 3.3.3 逻辑门电路图形符号

![逻辑门符号大全](..\示例图片\逻辑门符号大全.png)

![逻辑门符号大全2](..\示例图片\逻辑门符号大全2.png)

![逻辑门符号大全3](..\示例图片\逻辑门符号大全3.png)

### 3.3.4 逻辑门电路实现算数运算

- 设计流程：

  **真值表**—**逻辑函数表达式**—**逻辑电路图**

- 全加器

  1. 真值表

     ![ ](..\示例图片\全加器真值表.png)

     - Ci-1是来自低位的进位，S~i~是和，C~i~是进位

  2. 逻辑函数表达式

     ![全加器的逻辑表达式](..\示例图片\全加器的逻辑表达式.png)

  3. 简化并设计电路

     ![全加器逻辑表达式简化](..\示例图片\全加器逻辑表达式简化.png)

     ![全加器电路图](..\示例图片\全加器电路图.png)

### 3.3.5 逻辑门电路实现条件运算

## 3.4 时序逻辑电路—存储数据

- 背景：
  - 逻辑门电路和组合逻辑门电路中，**输入变化，输出也会变化，数据并没有存储下来。**
- 问题1：如何存储数据？如何提现对数据的记忆功能？
  - 存储数据和记忆功能应该有两种模式：
    1. 写模式：输出等于输入
    2. 记忆模式：数据已经保存，**输出不跟随输入，保持上一次状态**
  - 两种模式应该可以切换。满足这个才能称之为**存储数据**

### 3.4.1 RS触发器

- **实现存储功能**

  - 最难的部分是记忆模式，**输出等于上一次状态**
  - 巧妙的解决办法是，**把输出也拿来当输入**

- RS触发器的思路：

  1. 输入是$R$和$S$，输出是$Q$和$\overline{Q}$，当然为了记忆功能，$Q$和$\overline{Q}$也会当输入
  2. 写模式下：
     - 输入：$R=0$ ，$S=1$         输出：$Q=1$，$\overline{Q}=0$
     - 输入：$R=1$ ，$S=0$         输出：$Q=0$，$\overline{Q}=1$
  3. 记忆模式：
     - 输入：$R=0$ ，$S=0$         输出：$Q=Q$，$\overline{Q}=\overline{Q}$

  - 注意：输入还有一种可能：$R=1$ ，$S=1$，约定这是被禁止的操作，没有逻辑意义。

- RS触发器电路图：

  ![RS触发器电路图](..\示例图片\RS触发器电路图.png)

- RS触发器真值表：

  ![RS触发器真值表](..\示例图片\RS触发器真值表.png)

### 3.4.2 个人设计思路

- 根据存储器件的两种模式：
  1. 写入模式：
     - 输入：$M=1$ ，$I=1/0$         输出：$O=I$
  2. 记忆模式：
     - 输入：$M=0$ ，$I=1/0$         输出：$O=O$
- 暂时没想到电路图设计，这才提现RS触发器的巧妙。

# 4. 小数编码

- 背景

  计算机不仅需要存储整数，正负数，还要存储小数。小数的核心是小数点，小数点如何存储和处理，有两种思路：

  1. 定点数：小数点的位置**固定**。
  2. 浮点数：

  ==当然前提还是二进制，补码==

## 4.1 定点数

- 思路
  1. 整数部分和小数部分分开
  2. 一个8位的计算机，前5位表示整数部分，后3位表示小数部分
  3. 不同精度的数据类型，会用不同的位数去表示小数
- 缺点：
  - 数据表示范围太小，存储花销对计算机太大了

## 4.2 浮点数

- 思路

  - 想法很简单，科学计数法，比如：
    $$
    352050.12567=3.5205012567*10^5
    $$

  - 表示一个小数，只需要，**数值部分**，**符号部分**，**阶数部分**

- 浮点数表示，还是先表示为二进制补码，对应三部分

  1. 尾数，对应数值部分
  2. 阶码，对应阶数部分
  3. 数符，对应符号部分

- 根据IEEE754标准，64位计算机的长实数浮点表示：

  ![浮点数64位](..\示例图片\浮点数64位.png)

# 5. 微型计算机

- 问题1：微型计算机是什么？和其他类型计算机有什么区别？

  - **微型计算机**，简称**微机**，以微处理器为基础，配备存储器，$I/O$接口，外设的计算机。
  - 微机和其他计算机没有特别明确的区别。主要在用途，微机主要是个人电脑，小巧轻便，实用廉价等。其他类型的计算机有：
    1. **网络计算机**：专指某些**高性能计算机**，**能通过网络，对外提供服务**。相对于普通电脑来说，稳定性、安全性、性能等方面都要求更高，因此在CPU、芯片组、内存、磁盘系统、网络等硬件和普通电脑有所不同.
    2. **工业控制计算机**：简称**控制机**，是一种采用总线结构，对生产过程及其机电设备、工艺装备进行检测与控制的计算机系统总称。由**计算机和过程输入输出（I/O）**通过两大部分组成。计算机是由**主机、输入输出设备和外部磁盘机、磁带机**等组成。在计算机外部又增加一部分**过程输入/输出通道**，用来完成工业生产过程的检测数据送入计算机进行处理；另一方面将计算机要行使对生产过程控制的命令、信息转换成工业控制对象的控制变量的信号，再送往工业控制对象的控制器去。由控制器行使对生产设备运行控制。工控机的主要类别有：**IPC（PC总线工业电脑）**、**PLC（可编程控制系统）**、**DCS（分散型控制系统）**、**FCS（现场总线系统）**及**CNC（数控系统）**五种。
    3. **嵌入式计算机**：也叫**嵌入式系统**。是一种**以应用为中心**、**以微处理器为基础**，**软硬件可裁剪的**，适应应用系统对功能、可靠性、成本、体积、功耗等综合性严格要求的**专用计算机系统**。它一般由**嵌入式微处理器、外围硬件设备、嵌入式操作系统以及用户的应用程序**等四个部分组成。嵌入式系统几乎包括了生活中的所有电器设备，如掌上pda、计算器、电视机顶盒、手机、数字电视、多媒体播放器、汽车、微波炉、数字相机、家庭自动化系统、电梯、空调、安全系统、自动售货机、蜂窝式电话、消费电子设备、工业自动化仪表与医疗仪器等。

- 微机的组成：

  1. 主机
     - **中央处理器CPU**
       - **运算器ALU（算术和逻辑运算单元）**
       - **控制器**
       - **寄存器**
     - **存储器**
       - **RAM（读写存储器）**
       - **ROM（只读处理器）**
     - **$I/O$接口**
  2. 内部总线
     - **数据总线**
     - **控制总线**
     - **地址总线**
  3. 外设
     - **输入设备**：键盘、扫描仪、软硬磁盘、A/D转换器等
     - **输出设备**：打印机、绘图仪、D/A转换器等
  
  ![微机组成](..\示例图片\微机组成.png)

## 5.1 架构

- 计算机领域，架构的概念？
  - 计算机架构，简单说就是**计算机系统或组件**的**设计和结构**
  - 涵盖了**硬件**和**软件**层面的**组织、交互方式、指令集、数据通路**等各个方面
  - 计算机架构定义了计算机系统的基本特征和运行方式，以及各个组件之间的关系
- **计算机架构包含处理器架构，处理器架构包含指令集架构**

### 5.1.1 计算机架构

- **冯·诺依曼架构**

  - 原理：

    **软件包含数据和程序**，一起存入内存，有机器自动地执行**程序里的一条条指令**。

    

  ![冯诺依曼架构](..\示例图片\冯诺依曼架构.png)

- **哈佛架构**

  - 思想总结：
    1. 计算机应包括**运算器**、**存储器**、**控制器**、**输入**和**输出**设备五大基本部件
    2. 计算机内部采用**二进制来表示指令和数据**，每条指令一般具有一个**操作码**和一个**地址码**，其中操作码表示**操作性质**，**地址码指出操作数在存储器的地址**。
    3. 将编好的程序送入存储器中，然后启动计算机工作，计算机无需操作人员干预，能自动逐条取出指令和指令指令。

  ![哈佛架构](..\示例图片\哈佛架构.png)

### 5.1.2 处理器架构

- 概述

  - **处理器架构本质是指令集架构**，硬件结构组织在计算机架构已经规定好了。
  - 指令集主要是两种：**CISC和RISC指令集**，他们不是具体的指令集，而是两种**指令集设计理念**
  - 基于两种指令集设计理念，现代处理器架构具体指令集往往在CISC和RISC之间有所折衷，以平衡指令集的复杂性和执行效率。因此诞生众多处理器架构

- 参考：

  [一文看懂arm架构和x86架构有什么区别](https://zhuanlan.zhihu.com/p/95028674)

  [X86、ARM、RISC-V，MIPS傻傻分不清楚？一文带你看懂！](https://zhuanlan.zhihu.com/p/311359454)

- **x86架构**
  - 美国Intel公司（cpu厂商）开发，美国IBM公司（曾经电脑厂商）1981年推出的世界第一台PC机中的CPU–i8088（i8086简化版）使用的也是X86指令
  - 时至今日，Intel最新生产的CPU仍然保持了x86架构，一直以来都在个人计算机和服务器领域占据着重要地位。
  - 包括Core i9、Core i7、Core i5等系列，以及Xeon系列用于高性能服务器。这些处理器不断提升性能、功耗效率和安全特性，以满足不断变化的计算需求。
  - **遵循CISC指令集架构**，也引用了一些RISC的一些特征
  - **冯诺依曼架构**
- **ARM架构**
  - 最初由英国公司ARM Holdings（现在的Arm Limited）开发
  - ARM架构在**嵌入式系统**、**移动设备**、**嵌入式控制**和**其他低功耗应用**中得到了广泛应用
  - RISC架构
  - **低功耗**
  - **智能手机、平板电脑、可穿戴设备**等移动设备，**工业自动化、嵌入式控制器、物联网设备**等，**轻量级工作负载和节能服务器**，**游戏机、移动设备和嵌入式图像处理等**
  - **ARM的优势不在于性能强大而在于效率**，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致。
  - ARM系统几乎都采用Linux的操作系统
- **RISC-V架构**
  - RISC-V（发音为"risk-five"）是一种**开放、免费**的指令集架构（Instruction Set Architecture，ISA），它的设计旨在提供一种灵活的、可定制的架构，适用于各种应用和市场。
  - ==很重要，是趋势。==

### 5.1.3 指令集架构ISA

- 概述

  **CISC和RISC并不是具体的指令集，而是两种指令集设计理念**，**没有明确定义**

- 背景

  典型程序中80%的语句都是使用计算机中20%的指令，而这20%的指令都属于**简单指令**。因此花再多时间去研究**复杂指令**，也仅仅只有20%的使用概率。

- **指令集与硬件设计**

  - **指令集的设计与硬件设计之间存在密切关系，不同的指令集设计会直接影响处理器内部的组织、数据通路、控制单元等多个方面**

  1. 不同的指令集定义了不同的指令和操作，这就需要在硬件层面实现相应的**执行逻辑**
  2. 指令集定义了**指令的格式和编码方式**，硬件需要根据不同的指令格式设计指令解码逻辑，以正确地解释和执行每条指令。
  3.  **指令集决定了寄存器的数量、类型和使用方式，以及如何与存储器交互。**硬件设计必须提供相应的寄存器文件和内存访问逻辑。

#### 5.1.3.1 CISC

- 复杂指令集计算机  **Complex Instruction Set Computer**
- 特点：
  1. 指令数目一般多达200~300条
  2. 存在大量**复杂指令**。复杂指令可以执行多种操作，更多的时钟周期来执行。
  3. 指令长度不固定，指令格式种类多，寻址方式种类多
  4. 各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成（复杂）
  5. 可以访问**存储器**的指令不受限制
  6. 难以用优化编译生成高效的目标代码程序

#### 5.1.3.2 RISC

- 精简指令集计算机  **Reduced Instruction Set Computer**

- 思路：

  选取使用**频率较高的一些简单指令**以及**一些很有用但不复杂的指**令，让**复杂指令**的功能由使用频率高的**简单指令的组合**来实现。

- 特点：

  1. **指令长度固定**
  2. 只有**两个指令LOAD/STORE访问存储器**，其余指令的操作都在寄存器内完成
  3. CPU中有多个通用寄存器
  4. **流水线技术**，大部分**指令只在一个时钟周期内完成**
  5. 采用优化的编译程序

## 5.2 8086微处理器

- 问题1：**微处理器**是什么？跟中央处理器（**CPU**）有什么关系和区别？

  **微处理器=CPU**

- 问题2：**8086微处理器**特点是什么？为什么重点介绍8086微处理器？

  - 8086微处理器是一款由英特尔公司于1978年推出的**16位微处理器**，也同时开创了一个新时代：**X86架构诞生了**。它是最早的**x86处理器之一**，为**个人计算机**的发展奠定了基础。
  - 随着时间的推移，x86架构逐渐演进和扩展，成为个人计算机和服务器领域最为流行和常见的架构之一

### 5.2.1 处理器组成

- 微处理器，**CPU**，主要功能是运算和控制功能，组成：

  1. **运算器ALU**：
     - **Arithmetic Logic Unit** 算术逻辑单元
     - ALU负责处理整数和逻辑运算，它是CPU的核心部分之一，包括
       1. **算术运算：** ALU可以执行基本的算术操作，如加法、减法、乘法和除法。这些操作用于执行数值计算和数据处理。
       2. **逻辑运算：** ALU可以执行逻辑操作，如与、或、非、异或等。逻辑操作用于处理布尔逻辑，比如条件判断和位操作。
       3. **移位操作：** ALU可以执行位移操作，将二进制数的位向左或向右移动。移位操作在数据的移动和处理中很有用。
  2. **控制器**：
     - 控制器的主要功能是**存取**、**解释并执行**存储在**内存中的指令**。
     - 控制器任务包括：
       1. **指令解码：** 控制器从主存储器中读取指令，然后解码这些指令，**确定它们要执行的操作类型和操作数**。
       2. **时序控制：** 控制器==生成时序信号==，以便协调计算机中各个组件的操作，**确保指令按照正确的顺序执行**。
       3. **操作控制：** 控制器**根据指令的操作类型生成控制信号**，**指导ALU**（算术逻辑单元）执行算术和逻辑运算，以及**对寄存器和存储器的读写操作**。
       4. **分支控制：** 控制器可以检测条件并决定**是否跳转到其他指令地址**，用于**支持条件分支和循环等程序控制结构**。
       5. **异常处理：** 控制器可以检测硬件故障或软件异常，并采取适当的行动，例如**中断处理和异常处理**。
       6. **协调外部设备：** 控制器还可以与外部设备通信，管理I/O操作，使CPU与外设进行数据交换。
     - 控制器包括的关键部件：
       1. **指令寄存器（IR，Instruction Register）：** 用于存储当**前从主存储器中取得的指令**，供解码和执行。
       2. **程序计数器（PC，Program Counter）：** **存储下一条要执行的指令的地址**，用于跟踪程序的执行顺序。
       3. **时序生成器：** **生成时序信号**，以协调各个部件的操作，确保指令按正确的顺序执行。
       4. **指令解码单元：** **解析指令的操作码和操作数，确定要执行的操作类型。**
       5. **控制单元：** **生成控制信号**，指导其他部件执行特定的操作，如读取、写入、运算等。
       6. **分支控制逻辑：** 判断条件分支的条件，确定是否要进行跳转或分支操作。
       7. **时钟：** **提供系统的时钟脉冲**，用于同步各个部件的操作。
       8. **异常处理逻辑：** 处理硬件故障、中断和异常情况，以确保系统稳定运行。
       9. **控制存储器：** 存储微操作码（microcode）或控制指令，用于控制各个操作的执行。
       10. **地址生成逻辑：** 生成内存地址，用于从主存储器中读取指令和数据。
  3. 寄存器：
     - 寄存器（Register）是CPU内部的一组小型高速存储器单元，用于**暂时存储**和**处理****指令、数据和控制信息**的小型**高速**存储器单元
     - 常见寄存器：
       1. **通用寄存器：** 用于存储**临时数据**、**计算结果**和**中间值**。这些寄存器可以用于各种操作，如算术运算、逻辑运算和数据传递。通常有命名为**R0、R1、R2**等。
       2. **累加器（Accumulator）：** 用于**存储算术和逻辑操作的结果**，特别适合于累加运算。
       3. **数据寄存器：** 用于存储数据，支持各种操作，包括算术、逻辑、位移等。
       4. **地址寄存器：** 用于存储内存地址，以支持数据和指令的访问。包括内存地址寄存器（MAR）和内存缓冲寄存器（MBR）等。
       5. **状态寄存器（Flag Register）：** 存储运算结果的状态信息，例如零标志、负标志、溢出标志等。
       6. **栈指针寄存器（Stack Pointer，SP）：** 用于存储栈的顶部地址，支持函数调用、中断处理和数据存储。
       7. **基址寄存器（Base Register，BR）：** 用于存储指向存储器中某个区域的基地址，以支持相对寻址。
       8. **变址寄存器（Index Register，IR）：** 用于存储变址量，用于在相对寻址中计算有效地址。
       9. **指令寄存器（Instruction Register，IR）：** 存储当前从主存储器中取得的指令，供解码和执行。
       10. **溢出寄存器（Overflow Register）：** 用于存储算术运算的溢出情况。
  4. 内部总线，准确说，不输入处理器。
     - **数据总线**
       - 数据总线用于在CPU内的不同部件之间传输数据。它传输的是实际的数据，如操作数、计算结果等
       - 数据总线的宽度决定了每次传输的数据量，通常以位为单位（例如8位、16位、32位、64位等）。
     - **地址总线**
       - 地址总线用于在CPU内部的各个组件之间**传输内存地址**或外部设备的地址。
       - 地址总线的宽度决定了CPU可以寻址的不同地址。
     - **控制总线**
       - 控制总线用于在CPU内部的各个组件之间传输控制信号。
       - 这些信号涉及操作的控制，**如读/写操作、时钟信号、中断信号等**。
       - 控制总线的控制信号告知其他部件何时执行读取、写入、算术操作、逻辑操作等。
- 问题1：寄存器和存储器有什么区别？存储器的RAM和ROM有什么区别？

  - 寄存器：**Registers**，位于中央处理器（CPU）内部的一组**高速存储单元**，用于存储临时==**数据和指令**==。==寄存器是最快速的存储设备==，其访问速度比其他存储设备（如主存储器）要快得多。寄存器在执行指令、进行运算以及控制程序执行流程时起着关键作用。CPU使用寄存器来存储操作数、地址、指令以及一些控制信息，以便进行高速的数据操作和处理。
  - 存储器：Memory，又称为**主存储器**或**内存**，用于存储==**程序和数据**==，存储器的访问速度相对较慢，但它可以存储大量的数据和程序。存储器通常分为**随机存取存储器**（RAM）和**只读存储器**（ROM）
    1. **随机存取存储器**（RAM），Random Access Memory，**用于存储正在运行的程序和数据**。当计算机运行程序时，程序和数据会被加载到RAM中，以便CPU能够迅速访问并进行计算。RAM是一种易失性存储设备，意味着当计算机断电时，其中存储的数据将会丢失。
    2. **只读存储器**（ROM），Read-Only Memory，用于**存储固定的程序代码和数据**。这些数据在制造过程中被写入，并且通常无法随意修改。主要用途包括：
       - **引导程序（Bootloader）**：计算机启动时，BIOS或UEFI固件存储在ROM中，负责初始化硬件并加载操作系统。
       - **固件（Firmware）**：许多硬件设备（如显卡、声卡）的固件存储在ROM中，这些固件控制硬件的工作方式和功能。
       - **系统程序和设置**：某些ROM中存储了操作系统的核心部分、系统设置以及一些不需要频繁修改的数据。
       - **保留数据**：一些数据（如加密密钥）可以存储在ROM中，以保证其安全性和长期性。
  - 硬盘：通常指的是硬盘驱动器（Hard Disk Drive，HDD）或固态硬盘（Solid State Drive，SSD），跟存储器没有关系。**硬盘可以读写，断电不会丢失数据**。

  - 总结：
    1. 所谓的**内存是RAM**
    2. **硬盘并不是ROM**。ROM里的东西是写死的。
    3. 寄存器里存的是**指令**和数据，RAM里存的是正在运行的**程序**和数据
    4. ==指令集（Instruction Set）存储在计算机的存储器中，通常是存储在ROM中或者固件中==
- 问题2：程序和指令？

  - 两个不同的概念
  - **程序是一系列指令的集合**，用于告诉计算机如何执行特定的任务。程序通常由一系列指令按照特定的顺序组成，以完成所需的计算或操作。
  - 指令是计算机处理器（CPU）可以理解和执行的基本操作。每个指令包含一个操作码（opcode），它指示CPU执行特定的操作，例如加法、乘法、存储数据等。
- 参考：[计算机中各种位宽的含义 ](https://www.bilibili.com/read/cv19325810)

### 5.2.2 处理器功能结构

- 8086处理器**内部结构**从**功能**分为两个单元：
  1. 总线接口单元**BIU**
  2. 执行单元**EU**
- 总线接口单元**Bus Interface Unit**
- 执行单元**Execution Unit**

