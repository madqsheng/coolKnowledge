# 1.数据存储

- 概述：
  1. 计算机内的信息都是以二进制数表示，存储在内存中
  2. 计算机数据量的单位，从小到大包括：位(比特)，字节，字，双字，四字
  3. 计算机数据存储方式，决定了数据的最小计量单位是比特，1比特可以存一个1或者0。现实生活中的计量单位往往是个，只，米等。计量单位是物质存在原理决定。

## 1.1 位bit（比特）

- 更常见的称呼是比特，英文bit，简称b
- 计算机中度量数据的最小最基本的单位。
- 1比特其实就是一个物理空间，里面存储数据。由于数据是以二进制存在，1比特空间存的就是1或者0。

## 1.2 字节Byte

- 英文Byte，简称B，1B=8b 
- 虽然比特是数据的最小单位，但是字节才是最小可寻址单元，也就是数据存储位置的最小基本单位。一个字节有8位，也就是8bit，字节里的8位是共享一个地址。
- 每个字节的8比特数据往往被视为一个整体，按照连续的地址存储，允许计算机可以按照地址来寻址和访问字节数据。
- 问题1：既然字节内的比特数据共享一个地址，那么位操作是怎么找到对应的比特数据。

## 1.3 字、双字、四字

- 英文word，简写w
- 双字DW，四字QW
- 字是一个很重要的概念，是计算机内部进行数据传递、数据读写的最小单位。
- 1word等于多少Byte不固定。取决于处理器内部的通用寄存器的位数和数据总线的宽度。
- 计算机IBM PC/XT规定：
  - 1w=2B=16b
  - 1DW=4B
  - 1QW=8B

## 1.4 数量级 K/M/G/T

- K/M/G/T并没有是实质意义，只是一个数量级，类似于十/百/千/万，需要和数据单位一起用，比如KB,MB,GB,TB
- 在计算机里，1k=1024，原因在于存储数据的寄存器是二进制的，同时还要通过地址寄存器寻找数据寄存器里的数据，也就是寄存器既存数据，还计量有多少数据。1k=2^10^
- 同理：
  - 1k=2^10^=1024
  - 1m=2^20^=1024k
  - 1g=2^30^=1024m
  - 1t=2^40^=1024g

# 2.数据编码

- 数据有的分正负的，有的不分，也就是有符号数和无符号数。如何解决存储，一个朴素的想法是，先声明有无符号，无符号无需特殊设计，有符号的话，那么在存储空间（比如字节）内腾出一位区别正负，1代表正，0代表负；或则1代表负，0代表正
- 似乎数据表示设计就这样简单：最高位腾出来表示正负，1代表负，0代表正，其余位表示数值，这就是**原码**的思路：
  - +105  => 0 1101001      -105 => 1 1101001 
  - bug1:  +0 => 0 000000   +0 => 1 0000000
  - bug2: 1-2=1+(-2)   =>   0 0000001+1 0000010=1 0000011  =>  -3
  - 总结：原码思路，看似没问题，实际上0的表示不唯一，加减法（减法转换为加法）逻辑错误，虽然乘法和除法是对的。
- 改进一下思路：观察原码中正数和负数加法，符号位和数值位各自在相加，这是逻辑错误的原因。正数和负数相加，数值位应该相抵消，而不是相叠加，最终的符号位应该取决于哪边的数值位更大。所以要解决这个问题，正数或则负数的其中之一的数值位必须取反。这就是**反码**，具体编码就是，正数还是原码思路，负数的数值位取反，符号位不变：
  - 1-2=1+(-2)  =>  0 0000001+1 1111101=1 1111110  => - 1 (nice)
  - bug1: -1+(-2)  => 1 1111110 +1 1111101= 11 1111011 (溢出)
  - bug2: 1+(-1)  =>  0 0000001+1 1111110=1 1111111 => -0
  - bug3: +0 => 0 0000000    -0 => 1 1111111
  - 总结：反码思路，解决了一点正负数相加的问题，没有完全解决。0的表示还是不唯一，正负数太容易溢出了。
- 在改进一下思路：问题最关键也是最后的部分是0的编码，如何唯一编码0？反码里正负数溢出实际问题不大，-1+(-2)按照反码运算，最后得到11 1111011，去掉溢出的最高位就是1 1111011解码位-3，运算实际是正确的。那么来思考，如何唯一编码0？按照反码编码：+0 =0 0000000 ，-0 =1 1111111，怎样让他们统一呢？如果他们都+1会怎么样，前者变为0 0000001，后者变为：10 0000000溢出了，等一下，10 0000000去掉溢出位就是0 0000000，这不就是原码进而反码里的+0吗？为啥我非要两个一起+1啊？那如果编码思路就只规定负数的数值位取反再+1，正数不变，那么+0=0 0000000，-0 = 0 0000000，这就实现了唯一编码0，这就是**补码**思路。虽说，0唯一编码了，但是真的不太优雅，并且正数不变，负数加一，那么请问，最后加减法编码符合数学逻辑吗？拭目以待：
  -  1+(-2)  =>  0 0000001+1 1111110=1 1111111  => - 1 (nice)
  -  -1+2    =>  1 1111111+0 0000010=10 0000001  =>  1(溢出但正确)
  - -1+(-2)  =>  1 1111111+1 1111110=11 1111101 => -3(溢出但正确) 
  -  -1+1    =>  1 1111111+0 0000001=10 0000000  =>  0(溢出但正确)
  - 总结：唯一编码0，并且编码后的加减法再解码回去，可能会溢出，去掉溢出位以后，结果任然符合数学逻辑。
  - 补码编码：正数，符号位是0，数值位二进制照常表示；负数，符号位是1，数值位先二进制表示，然后数值位取反，然后数值位再+1，如果溢出则去掉溢出位。

## 2.1 原码

- 编码：
  1. 有符号数专属概念，设计符号位和数值位
  2. 最高位是符号位，后面是数值位
  3. 符号位为0表示正数，符号位为1表示负数
  4. 数值位二进制表示
- 解码：
  1. 符号位区分胜负
  2. 数值位二进制转换为十进制

## 2.2 反码

- 编码：
  1. 改进原码，符号位不变
  2. 正数的数值位不变，但是负数的数值位取反
- 解码：
  1. 先看符号位判断正负
  2. 如果是正数，数值位直接二进制转十进制
  3. 如果负数，数值位先取反，再二进制转十进制

## 2.3 补码

- 编码：
  1. 改进反码，符号位仍然不变
  2. 正数的数值位不变
  3. 负数的数值位先取反然后再+1，如果溢出则去掉溢出位
- 解码：
  1. 先看符号位判断正负
  2. 如果是正数，数值位直接二进制转十进制
  3. 如果负数，数值先-1，然后位取反，最后二进制转十进制

## 2.4 总结

1. 大前提，如果先声明是无符号数，直接二进制表示，不需要原码反码补码这么复杂的编码。
2. 如果声明是有符号数，在计算机中的编码方式是**补码**

# 3.数据运算

## 3.1加减乘除

## 3.2 为什么  

# 4.电路基础（待补充）

## 4.1 半导体

- 概述
  1. 半导体是一种介于导体（如金属）和绝缘体（如非金属）之间的材料，一种材料类别，是所有电子器件的基础。
  2. 基于半导体材料制造的电子元件有：晶体管，二极管，太阳能电池
- 为什么现代电子器件选择半导体材料而不选择导电性更好的金属材料？
  - 根本原因是半导体材料在特定条件下导电性会改变，通过导电性改变可以实现很多逻辑，比如：
    - **可控性：** 半导体的导电性可以通过控制电场或电流来改变，这为制造可编程、可调节的器件提供了可能性。相比之下，金属导体的导电性较为固定，难以在电场或电流的作用下调整。
    - **开关性能：** 半导体材料的导电性在不同条件下可以发生改变，使其能够实现电子开关功能。这使得半导体材料适用于逻辑门、晶体管等电子器件的制造，从而支持数字电路的实现。
    - **电子移动性：** 在半导体中，电子的移动性介于导体和绝缘体之间。这意味着半导体可以在一定条件下导电，但又不会像金属一样形成非常低电阻的通路，从而有助于控制电流。
    - **能隙：** 半导体具有带隙（能隙），在其能带结构中，存在一个禁带（能隙）使得电子在一些情况下无法自由地跃迁。这个特性使得半导体能够实现对电流的控制，例如在二极管中的单向导电。
    - **温度敏感性：** 半导体的电导率随着温度的变化而变化，这使得半导体在温度传感器、热敏电阻等应用中非常有用。
- 什么是超导材料？室温超导有什么意义？
  1. 超导材料是一种在低温条件下表现出**零电阻**和**完全排斥磁场**的特性的材料。
     - 
  2. 室温超导是指在接近或达到室温（通常指摄氏20度或更高温度）时，材料仍然可以表现出超导特性。

## 4.2 模拟电路

## 4.3 数字电路





