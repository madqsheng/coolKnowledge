# 概述

- 局限的讨论，计算机编程领域的数据结构与算法
- 数据结构
  - 数据结构包括三个方面：
    1. 数据**组织方式**：数据结构涉及如何组织和管理数据，以便于访问和操作。这包括**数据元素之间的关系**、**数据的层次结构和组织方式**，以及**数据的逻辑结构**。常见的数据组织方式包括**线性结构**（如数组和链表）和**非线性结构**（如树和图）。
    2. 数据的**物理存储方式**：这部分关注数据在计算机内存中的实际存储方式。它包括数据**在内存中的布局**、**存储单元的选择**（如数组的连续内存块和链表的分散节点），以及如何最大限度地**提高数据访问的效率**。
    3. 数据的**读写方式**：数据结构定义了如何访问和操作存储在其中的数据。这包括数**据的插入、删除、查找，修改**等基本操作，以及如何有效地执行这些操作的算法。这也涉及到数据的遍历方式和访问权限管理。
  - **数据结构的选择**取决于**特定问题的需求**，不同的数据结构具有不同的优缺点，可以用来解决不同类型的问题。
  - 在现代编程语言和开发环境中，许多常见的数据结构已经作为**标准库或内置类型**提供，开发者通常无需自己从头开始实现这些**数据结构的存储**和**基本操作（增删改查）**。
  - 常见的数据结构：
    1. **数组（Array）**：一组具有相同数据类型的元素，通过索引访问，具有固定大小。
    2. **链表（Linked List）**：元素通过节点连接起来的线性数据结构，包括单向链表、双向链表和循环链表。
    3. **栈（Stack）**：一种线性数据结构，遵循先进后出（LIFO）原则，用于实现函数调用、表达式求值等。
    4. **队列（Queue）**：一种线性数据结构，遵循先进先出（FIFO）原则，通常用于任务排队和广度优先搜索（BFS）等算法。
    5. **树（Tree）**：非线性数据结构，包括二叉树、二叉搜索树（BST）、平衡二叉树（AVL 树）等，用于层次化数据表示和搜索。
    6. **图（Graph）**：非线性数据结构，由节点和边组成，用于表示复杂的关系网络，如社交网络、网络拓扑等。
    7. **哈希表（Hash Table）**：使用哈希函数将键映射到值的数据结构，用于高效的键-值对存储和查找。
    8. **堆（Heap）**：一种特殊的树结构，通常用于实现优先队列，包括最小堆和最大堆。
    9. **字典（Dictionary）**：键值对的集合，类似于哈希表，但通常指的是高级编程语言中的数据结构，如Python中的字典。
    10. **集合（Set）**：元素无序且不重复的数据结构，通常包括集合运算，如并集、交集和差集。
    11. **队列（Deque）**：双端队列，支持在两端插入和删除元素的数据结构。
    12. **树结构的扩展**：包括字典树（Trie）、红黑树、B 树、B+ 树等用于特定目的的树结构。
    13. **图结构的扩展**：包括有向图、无向图、加权图、拓扑排序等。
- 算法
  - 用于解决特定问题或执行特定任务的方法。
  - 以输入数据作为起点，通过一系列有限的步骤来产生所需的输出

# 1. 数组

- 概述
  - **线性**数据结构，用于存储一组**相同数据类型**的元素，并通过**索引来访问**这些元素

- 存储方式

  - **连续内存分配：** 数组的元素在内存中是**连续存储**的，这意味着每个元素都在前一个元素的后面，没有额外的空间分隔。这种连续的存储方式使得访问数组元素非常高效，因为可以通过简单的数学计算来确定元素的内存位置。
  - **固定大小：** **数组的大小通常在创建时固定**，即在声明数组时指定其容量。这个容量不能动态改变，因此数组不适用于需要频繁插入或删除元素的情况。
  - **元素类型：** 数组中的所有元素都必须具有**相同的数据类型**，这个数据类型在数组声明时指定。例如，一个整数数组只能存储整数值。

- 操作

  - **访问元素：** 数组通**过索引来访问元素**，索引通常从0开始，依次递增。例如，要访问数组中的第三个元素，可以使用索引2（因为索引从0开始计数）。
  - **插入元素：** 在固定大小的数组中，插入元素通常需要将已有元素向后移动以腾出位置。这可能涉及到复杂的操作，尤其是在数组的中间插入元素时。
  - **删除元素：** 类似于插入，删除元素通常需要将后续元素向前移动以填补删除的位置。
  - **更新元素：** 可以通过索引来更新数组中的元素的值。
  - **遍历：** 数组可以通过循环来遍历所有元素，以执行各种操作，例如查找最大值、计算总和等。
  - **查找元素：** 数组的元素可以通过线性搜索（遍历）来查找，或者在特定情况下，如果数组已经按照某种顺序排列，可以使用二分查找等更快的算法。

- 代码实现

  1. Python 中的内置 `list` 数据类型

     - Python 中的内置 `list` 数据类型**并不是严格的数组**。
     - Python 的 `list` 具有以下特点：
       1. **动态大小：** 你可以在不指定大小的情况下创建一个空的 `list`，然后随时向其添加或删除元素，它会根据需要自动调整大小。
       2. **元素类型不限：** 一个 `list` 可以包含不同数据类型的元素，例如整数、字符串、列表等。
       3. **高级操作：** Python 的 `list` 提供了许多内置方法，用于执行元素的插入、删除、更新、查找等操作，这使得它在许多情况下更灵活和方便。
       4. **灵活的迭代：** 你可以使用 `for` 循环轻松遍历 `list` 中的元素。
     - Python 的 `list` 数据类型在**物理层面存储**的是**指向对象的引用（或指针）**，而不是直接存储对象本身。这使得list可以存储不同类型的元素。

  2. python中的**内置模块`array`**

     ```python
     from array import array
     
     #创建数组
     '''
     函数接受两个参数：
         1.第一个参数是数据类型代码，用来指定数组中元素的数据类型。例如，'i'表示整数，'f'表示浮点数，'d'表示双精度浮点数等。
         2.第二个参数是可迭代对象，用来初始化数组的内容。
         
     支持的数据类型：
     array模块支持多种数据类型，包括但不限于：
     
     'b'：有符号字节（signed byte）
     'B'：无符号字节（unsigned byte）
     'i'：有符号整数（signed integer）
     'I'：无符号整数（unsigned integer）
     'f'：浮点数（float）
     'd'：双精度浮点数（double）
     '''
     my_array = array('i', [1, 2, 3, 4, 5])
     #数组操作
     my_array.append(6)  # 向数组添加元素
     my_array.pop(2)    # 删除索引为2的元素
     value = my_array[3] # 获取索引为3的元素
     sub_array = my_array[1:4]  # 创建子数组
     ```

     - 注意：
       1. 数组本身大小是固定的，上面提到操作方法中的**添加和删除元素**，是在特定情况下可以**模拟这些操作**，但**实际上并没有动态调整数组的大小**。这些操作实际上是**创建一个新的数组**，并将数据从旧数组复制到新数组，然后使用新数组替换旧数组。
       2. `array`模块的一个主要优势是其在**处理大量数据时的性能**。由于数组中的元素在内存中是连续存储的，因此它们的访问速度通常比Python列表更快，特别是对于数值计算等需要高性能的任务。

  3. 自己动手

     ```python
     import copy
     
     class MyArray:
         # 定义数据类型映射字典，将data_type和对应的数据类型关联起来
         data_type_mapping = {
             'b': 'signed byte',
             'B': 'unsigned byte',
             'i': 'signed integer',
             'I': 'unsigned integer',
             'f': 'float',
             'd': 'double',
         }
         data_type_mapping = {
         'b': 'int',
         'B': 'int',
         'i': 'int',
         'I': 'int',
         'f': 'float',
         'd': 'float',
     }
         def __init__(self, data_type:str,init_data:list):
             self.data_type = data_type
             self.data = init_data
             #检查数据类型
             assert self.data_type in self.data_type_mapping, f"无效的data_type: {self.data_type}"
             self.expected_data_type = self.data_type_mapping[self.data_type]
             for value in self.data:
                 assert isinstance(value, eval(self.expected_data_type)), f"init_data中的数据类型不一致，期望的数据类型为{self.expected_data_type}"
             self.size = len(self.data)
             
     	#插入元素
         def insert(self, index, value):
             assert isinstance(value, eval(self.expected_data_type))
             if index > self.size or index < -self.size-1:
                 raise IndexError("Index out of bounds")
             else:  
                 self.data=copy.copy(self.data)
                 if index >= 0 :
                     self.data.insert(index,value)
                 else:
                     self.data.insert(index+self.size+1,value)
                 self.size = len(self.data)
         
         #添加元素
         def append(self,value):
             assert isinstance(value, eval(self.expected_data_type))
             self.data=copy.copy(self.data)
             self.data.append(value)
             self.size = len(self.data)
     	
         #删除元素
         def pop(self, index=None):
             if index is None:
                 self.data.pop()
                 self.size = len(self.data)
             elif index >= self.size or index < -self.size:
                 raise IndexError("Index out of bounds")
             else:
                 self.data=copy.copy(self.data)
                 if index >=0:
                     self.data.pop(index)
                 else :
                     self.data.pop(index+self.size)
             
         #修改元素，和对象+索引+赋值联动
         def __setitem__(self, index, value):
             assert index <self.size
             assert isinstance(value, eval(self.expected_data_type))
             '''
             魔法方法，和对象+索引+赋值联动：
             1.实例化一个对象obj，obj[i]=value会执行__setitem__(i,value)
             2.参数index, value没有要求
             '''
             self.data[index] = value
     	
         #查询数组,和print函数联动
         def __str__(self):
             '''
             魔术方法，和对象联动：
             1. 实例化一个对象obj，print(obj)输出的是否__str__返回值
             2.这里其实不需要print来触发__str__函数
             3.返回值必须是str类型
             '''
             return str(self.data)
         
         #查询元素，和对象+索引联动
         def __getitem__(self, index):
             assert index < self.size
             '''
             魔法方法，和对象+索引联动
              1. 实例化一个对象obj，obj[i]输出的是否__getitem__(i)返回值
              2.传参index是索引，通常是int类型，但不是必须
             '''
             return self.data[index]
     ```
     

# 2.链表

- 概述
  - 链表出现的动机是，**不必连续的存储空间**。
  - 链表由一系列**节点**组成，每个节点包含**数据**和一个**指向下一个节点的引用**（或**指针**）
  - 链表分类有：**单向链表，双向链表，循环链表**
- 存储方式
  1. **单向链表**：单向链表中的每个节点包含**数据**和一个**指向下一个节点的指针**。这种结构相对简单，**适用于顺序访问数据**。链表的**头节点用于定位整个链表**，**最后一个节点的指针通常指向null，表示链表的结束**。
  2. **双向链表**：双向链表的节点除了包含**数据**和**指向下一个节点的指针**外，还包含一个**指向前一个节点的指针**。这使得双向链表可以在**前向和后向方向上都有效地遍历**，但它相对于单向链表**需要更多的内存**来存储额外的指针。
  3. **循环链表**：循环链表是一种特殊的链表，其中**最后一个节点的指针指向第一个节点**，形成一个循环结构。这使得循环链表适用于需要循环访问数据的情况，比如游戏循环或轮询操作。
- 操作：
  - **插入和删除**：链表允许在O(1)时间内插入或删除节点，只需要更新相邻节点的指针即可。这使得链表在动态数据结构中非常有用，因为它们不需要像数组那样重新分配内存。
  - **查找**：单向链表的查找通常需要O(n)时间，因为必须从头节点开始逐个遍历直到找到目标节点。双向链表在某些情况下可以加速查找，但仍然需要线性时间。对于快速查找，哈希表或二叉搜索树可能更合适。
  - **内存管理**：链表的内存管理相对容易，因为它们不需要预先分配固定大小的内存空间。节点可以根据需要动态分配和释放，这使得链表适用于不确定数据大小的情况。

# 3. 栈

# 4. 队列

# 5. 树

# 6. 图

# 7. 哈希表

# 8. 堆



 



